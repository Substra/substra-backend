import enum
import logging
from typing import Callable, Dict, List

import structlog
from celery.events import state as celery_state
from prometheus_client import metrics, metrics_core

from metrics_exporter import settings

State = celery_state.State

structlog.configure(
    wrapper_class=structlog.make_filtering_bound_logger(
        logging.getLevelName(settings.LOG_LEVEL)
    )
)
logger = structlog.get_logger()


class MetricsNames(enum.Enum):
    """An enum of metrics names used in CeleryCollector
    """
    CELERY_WORKER_UP = 1
    CELERY_TASKS_ACTIVE = 2


class CeleryCollector:
    """Collector for Celery metrics
    It is built around the celery state to keep track of tasks progress.
    Celery event handlers should be registered on the celery app.
    """

    def __init__(self, registry, state: State) -> None:

        self._metrics = {}

        self._metrics[MetricsNames.CELERY_WORKER_UP] = metrics.Gauge(
            "celery_worker_up",
            "Indicates if a worker has recently sent a heartbeat",
            ["hostname"],
        )

        self._metrics[MetricsNames.CELERY_TASKS_ACTIVE] = metrics.Gauge(
            "celery_tasks_active", "Number of active tasks on the worker", ["hostname"]
        )

        self._celery_state = state

        if registry:
            registry.register(self)

    def heartbeat_handler(self, event) -> None:
        """Process worker-heartbeat events to set metrics

        Args:
            event (Any): the heartbeat event
        """
        worker = self._celery_state.event(event)[0][0]
        logger.debug(
            "Received event",
            alive=worker.alive,
            hostname=worker.hostname,
            active=worker.active,
        )
        self._metrics[MetricsNames.CELERY_WORKER_UP].labels(worker.hostname).set(
            1 if worker.alive else 0
        )
        # Here worker.active can be None for the first heartbeat
        self._metrics[MetricsNames.CELERY_TASKS_ACTIVE].labels(worker.hostname).set(
            worker.active or 0
        )

    @property
    def handlers(self) -> Dict[str, Callable]:
        """returns a dict of Celery events handlers

        These handlers should be registered on the celery app through an event reciever.
        celery docs: https://docs.celeryproject.org/en/v5.2.0/userguide/monitoring.html#real-time-processing

        Returns:
            Dict[str, Callable]: a dict of event handlers
        """
        return {
            "*": self._celery_state.event,
            "worker-heartbeat": self.heartbeat_handler,
        }

    def collect(self) -> List[metrics_core.Metric]:
        """Collects all the Celery metrics

        Returns:
            List[metrics_core.Metric]: A List of celery metrics generated by this collector
        """
        aggregated_metrics = []
        for metric in self._metrics.values():
            aggregated_metrics.extend(metric.collect())
        return aggregated_metrics
